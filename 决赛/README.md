# 2020华为软件精英挑战赛-决赛


## 赛题分析
计算每个账户的位置中心关键性（betweenness centrality）。

基本思想为以每个点出发做dijstra，求出到个点的单源最短路径，并且按拓扑序反向递推计算中心性cb，具体可参考文章“A Faster Algorithm for Betweenness Centrality”。


## 具体实现
（1）对于dij前驱节点的保存，使用静态数组和vector结合的方法。对于大部分节点使用长度为2的静态数组足够保存其前驱，并使用vector处理特殊节点。<br>
（2）针对官方数据1，使用暴力出奇迹大佬分享的scc缩链方法，避免对单链上的点重复计算，并结合id重映射可以取得较大优化。<br>
（3）虽然题目要求金额不超过2^31，但实际数据金额范围为[5-100]，因此优先采用桶优化dij，对于路径长度超出65536部分放入普通二叉堆中。（实测线上数据不存在这种情况）<br>
（4）对于二叉堆采取1/10000概率重整方法，扔掉无效边重新建堆可使二叉堆dij的性能得到明显提升。<br>
（5）使用压缩前向星存图的方式，观察到官方数据金额较小，且图的点数在250w以内，因此我们使用32b+32b，32b+16b和22b+10b三种模式存图并根据读入金额最大值自动切换，获得更加紧凑的存储结构。（实测线上数据均能使用22+10模式即一个uint32存储id和金额）。<br>